/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi
Eliminadas producciones para manejar globos
Agregado el esqueleto para la traduccion
Modificado por Silvia Takahashi 
Re: Agregar Reglas para el manejo de globos
Modificado por Saulo Daza y Sonia Vivas
Modificado por Silvia Takahashi
Eliminadas reglas de traducci�n DE  MARCROS
Cambio del lenguaje de comandos
Modificado por Silvia Takahashi: algunas Reglas para traduccion
Modificado por Silvia Takahashi: Cambio en el lenguaje
Abril: 2008 - Simplificado apra solo interpretaci�n
 **/

options
{
  LOOKAHEAD= 2;

  IGNORE_CASE = true;
  STATIC = false;
  FORCE_LA_CHECK = true; /* Toca setear esto en true porque sino el LOOKAHEAD = 2 manda warning */
}

PARSER_BEGIN(Robot)
package uniandes.lym.robot.control;
import uniandes.lym.robot.kernel.*;
import java.awt.Point;
import java.io.*;
import java.util.*;
@ SuppressWarnings("serial") 
public class Robot
{
  HashMap < String, Integer > variables = new HashMap < String, Integer > ();

  private RobotWorldDec world;

  void setWorld(RobotWorld w)
  {
    world = (RobotWorldDec) w;	
  }
  String salida = new String();
}

PARSER_END(Robot)

SKIP :
{
  " "
| 	"\r"
| 	"\t"
  //	| "\n"
}

TOKEN : /* SEPARATORS */
{
  < LPAREN : "(" >
| < RPAREN : ")" >
}

TOKEN : /* COMMANDS */
{
  < DEFVAR : "defvar" >
| < MOVE : "move" >
| < PUT : "put" >
| < PICK : "pick" >
| < TURN : "turn" >
| < FACE : "face" >
| < MOVE_DIR : "move_dir" >
| < RUN_DIRS : "run_dirs" >
| < MOVE_FACE : "move-face" >
| < SEARCH : "search" >
| < SK : "skip" >
}

TOKEN : /* CONTROL STRUCTURES */
{
  < IF : "if" >
| < LOOP : "loop" >
| < REPEAT : "repeat" >
| < DEFUN : "defun" >
}

TOKEN : /* CONDITIONALS */
{
  < FACING_P : "facing-p" >
| < CPU : "can-put-p" >
| < CPI : "can-pick-p" >
| < CM : "can-move-p" >
| < NOT : "not" >
}

TOKEN : /*CONSTANTS*/
{
  < BALLOONS : ":balloons" >
| < CHIPS : ":chips" >
}

TOKEN :
{
  < NUMERO : (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
| < #ALPHABET : [ "a"-"z" ] >
| < CONSTANT : ":" (< ALPHABET >)+ >
| < WORD : (< ALPHABET >)+ >
}

boolean command(StringBuffer sistema) :
{	
  salida = new String();
}
{
  (
    < LPAREN > < MOVE > move() < RPAREN >
  | < LPAREN > turn() < RPAREN >
  | < LPAREN > < FACE > face() < RPAREN >
  | < LPAREN > moveface() < RPAREN >
  | < LPAREN > < PUT > putItem() < RPAREN >								
  | < LPAREN > < PICK > pickItem() < RPAREN >
  | < LPAREN > variable() < RPAREN >
  | < LPAREN > searchKey() < RPAREN >
  )
  "\n"
  {
    //  try {
    //		 Thread.sleep(1);
    //   } catch (InterruptedException e) {
    //	        System.err.format("IOException: %s%n", e);
    //	    }
    sistema.append(salida);
    return true;
  }
| "\n"
  {
    return true;
  }
| < EOF >
  {
    return false;
  }
}

void putItem() :
{
  int f = 1;
}
{
  (
    < CHIPS > f = numero()
    {
      world.putChips(f);
    }
  )
|	
  (
    < BALLOONS > f = numero()
    {
      world.putBalloons(f);
    }
  )	
}

void pickItem() :
{
  int f = 1;	
}
{
  (
    < CHIPS > f = numero()
    {
      world.pickChips(f);
    }
  )
|	
  (
    < BALLOONS > f = numero()
    {
      world.grabBalloons(f);
    }
  )	
}

void move() :
{
  int x = 1;
}
{
  (
    x = numero()
    {
      world.moveForward(x);
      salida = "Command: Moveforward ";
    }
  )
}

void moveface() :
{}
{
  (
    < MOVE_FACE > face()
  )
}

void turn() :
{
  Map < String, Integer > directions = Map.of(
  ":right", 1, 
  ":around", 2, 
  ":left",-1
  );
  String c;
}
{
  (
    < TURN > c = constant()
    {
      if (directions.containsKey(c))
      {
        int giros = directions.get(c);
        int giro = 1;
        if (giros < 0)
        {
          giro = Math.floorMod(giros, 4);
        }
        else if (giros > 1)
        {
          giro = giros;
        }
        for (int i = 1; i <= giro; i++)
        {
          world.turnRight();
        }
        salida = "The robot has turned " + c;
      }
      else
      {
        salida = "The direction doesn't exist";
      }
    }
  )
}

void searchKey() :
{
  String key;
}
{
  < SEARCH > key = var()
  {
    if (variables.containsKey(key))
    {
      salida = "YES";
    }
    else
    {
      salida = "NO";
    }
  }
}

HashMap < String, Integer > variable() :
{
  String name;
  int n = 1;
}
{
  (
    name = var() n = numero()
    {
      if (variables.containsKey(name))
      {
        salida = "The variable alredy exists";
      }
      else
      {
        variables.put(name, n);
      }
      return variables;
    }
  )
}

void assing() :
{
  String name;
  int n;
}
{
  "="
}

void face() :
{
  Map < String, Integer > orientations = Map.of(
  ":north", 0, 
  ":east", 1, 
  ":south", 2, 
  ":west", 3
  );
  Map < Integer, Integer > turns = Map.of(
  0, 0, 
  1, 2, 
  2, 1, 
  3, 3
  );
  String o;
  int x = 1;
}
{
  (
    o = constant()
    {
      int inicio = world.getFacing();
      inicio = turns.get(inicio);
      int llegada = orientations.get(o);
      int nuevaOrientacion = llegada - inicio;
      int giros = Math.floorMod(nuevaOrientacion, 4);
      for (int i = 1; i <= giros; i++)
      {
        world.turnRight();
      }
    }
  | x = numero() o = constant()
    {
      int inicio = world.getFacing();
      inicio = turns.get(inicio);
      int llegada = orientations.get(o);
      int nuevaOrientacion = llegada - inicio;
      int giros = Math.floorMod(nuevaOrientacion, 4);
      for (int i = 1; i <= giros; i++)
      {
        world.turnRight();
      }
      world.moveForward(x);
    }
  )
}

/**
	 *  reconoce un numero entero sin signo
	 * @return el valor entero correspondiente al valor reconocido
	 */

int numero() throws Error :
{	
  int total = 1;
}
{
  < NUMERO >
  {
    try
    {
      total = Integer.parseInt(token.image);
    }
    catch (NumberFormatException ee)
    {
      // Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
      // Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
      throw new Error("Number out of bounds: " + token.image + "!!");
    }
    return total;
  }
}

/**
	 * reconoce una constante
	 * @return el valor string correspondiente al valor reconocido
	 */


String constant() throws Error :
{
  Token token;
}
{
  (token = < CONSTANT >)+
  {
    return token.image;
  }
}

/**
	 * reconoce una variable
	 * @return el valor string correspondiente al valor reconocido
	 */

String var() throws Error :
{
  Token token;
}
{
  (token = < WORD >)+
  {
    return token.image;
  }
}
