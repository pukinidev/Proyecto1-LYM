/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi
Eliminadas producciones para manejar globos
Agregado el esqueleto para la traduccion
Modificado por Silvia Takahashi 
Re: Agregar Reglas para el manejo de globos
Modificado por Saulo Daza y Sonia Vivas
Modificado por Silvia Takahashi
Eliminadas reglas de traducci�n DE  MARCROS
Cambio del lenguaje de comandos
Modificado por Silvia Takahashi: algunas Reglas para traduccion
Modificado por Silvia Takahashi: Cambio en el lenguaje
Abril: 2008 - Simplificado apra solo interpretaci�n
 **/

options
{
  LOOKAHEAD= 2;

  IGNORE_CASE = true;
  STATIC = false;
  FORCE_LA_CHECK = true; /* Toca setear esto en true porque sino el LOOKAHEAD = 2 manda warning */
}

PARSER_BEGIN(Robot)
package uniandes.lym.robot.control;
import uniandes.lym.robot.kernel.*;
import java.awt.Point;
import java.io.*;
import java.util.*;
@ SuppressWarnings("serial") 
public class Robot
{
  private RobotWorldDec world;

  void setWorld(RobotWorld w)
  {
    world = (RobotWorldDec) w;	
  }
  String salida = new String();
}

PARSER_END(Robot)

SKIP :
{
  " "
| 	"\r"
| 	"\t"
  //	| "\n"
}

TOKEN : /* SEPARATORS */
{
  < LPAREN : "(" >
| < RPAREN : ")" >
}

TOKEN : /* COMMANDS */
{
  < DEFVAR : "defvar" >
| < MOVE : "move" >
| < PUT : "put" >
| < PICK : "pick" >
| < TURN : "turn" >
| < FACE : "face" >
| < MOVE_DIR : "move_dir" >
| < RUN_DIRS : "run_dirs" >
| < MOVE_FACE : "move_face" >
| < SK : "skip" >
}

TOKEN : /* CONTROL STRUCTURES */
{
  < IF : "if" >
| < LOOP : "loop" >
| < REPEAT : "repeat" >
| < DEFUN : "defun" >
}

TOKEN : /* CONDITIONALS */
{
  < FACING_P : "facing-p" >
| < CPU : "can-put-p" >
| < CPI : "can-pick-p" >
| < CM : "can-move-p" >
| < NOT : "not" >
}

TOKEN : /*CONSTANTS*/
{
  < BALLOONS : ":balloons" >
| < CHIPS : ":chips" >
}

TOKEN :
{
  < NUMERO : (< DIGIT >)+ >
| < CONSTANT : ":" (< LETTER >)+ >
| < #DIGIT : [ "0"-"9" ] >
| < #LETTER : [ "a"-"z" ] >
}

boolean command(StringBuffer sistema) :
{	
  salida = new String();
}
{
  (
    < LPAREN > move() < RPAREN >
  | < LPAREN > < PUT > putItem() < RPAREN >								
  | < LPAREN > < PICK > pickItem() < RPAREN >
  | < LPAREN > turn() < RPAREN >
  | < LPAREN > face() < RPAREN >
  | < LPAREN > parseConstant() < RPAREN >
  )
  "\n"
  {
    //  try {
    //		 Thread.sleep(1);
    //   } catch (InterruptedException e) {
    //	        System.err.format("IOException: %s%n", e);
    //	    }
    sistema.append(salida);
    return true;
  }
| "\n"
  {
    return true;
  }
| < EOF >
  {
    return false;
  }
}

void putItem() :
{
  int f = 1;	
}
{
  (
    < CHIPS > f = numero()
    {
      world.putChips(f);
    }
  )
|	
  (
    < BALLOONS > f = numero()
    {
      world.putBalloons(f);
    }
  )	
}

void pickItem() :
{
  int f = 1;	
}
{
  (
    < CHIPS > f = numero()
    {
      world.pickChips(f);
    }
  )
|	
  (
    < BALLOONS > f = numero()
    {
      world.grabBalloons(f);
    }
  )	
}

void move() :
{
  int x = 1;
}
{
  (
    < MOVE > x = numero()
    {
      world.moveForward(x);
      salida = "Command: Moveforward ";
    }
  )
}

void turn() :
{
  Map < String, Integer > directions = Map.of(
  ":right", 1, 
  ":around", 2, 
  ":left", 3
  );
  String c;
}
{
  (
    < TURN > c = constant()
    {
      int giros = directions.get(c);
      salida = "Numero de giros: " + giros;
      for (int i = 1; i <= giros; i++)
      {
        world.turnRight();
      }
    }
  )
}

void face() :
{}
{
  < FACE >
  {
    int directions = world.getFacing();
    String d = "";
    switch (directions)
    {
      case 0 : 
      d = "North";
      break;
      case 1 : 
      d = "South";
      break;
      case 2 : 
      d = "East";
      break;
      case 3 : 
      d = "West";
      break;
    }
    salida = "The robot direction is: " + d;
    /* Estaba mirando si obtener el facing estaba funcionando y en efecto funciona! */

  }
}

void parseConstant() :
{
  String text;
}
{
  (
    < DEFVAR > text = constant()
    {
      salida = "constante: " + text;
    }
  )
}

/**
	 *  reconoce un numero entero sin signo
	 * @return el valor entero correspondiente al valor reconocido
	 */

int numero() throws Error :
{	
  int total = 1;
}
{
  < NUMERO >
  {
    try
    {
      total = Integer.parseInt(token.image);
    }
    catch (NumberFormatException ee)
    {
      // Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
      // Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
      throw new Error("Number out of bounds: " + token.image + "!!");
    }
    return total;
  }
}

/**
	 * reconoce una constante
	 * @return el valor string correspondiente al valor reconocido
	 */


String constant() throws Error :
{
  Token token;
}
{
  (token = < CONSTANT >)+
  {
    return token.image;
  }
}
